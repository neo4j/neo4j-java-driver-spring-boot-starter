= Using Neo4j's Spring Boot integration for the Java Driver
:toc:
ifndef::manualIncludeDir[]
:manualIncludeDir: ../
endif::[]
:neo4j-java-driver-spring-boot-starter_version: 1.0.0-alpha03
:groupId: org.neo4j.driver
:artifactId: neo4j-java-driver-spring-boot-starter
:spring-boot_version: 2.1.6.RELEASE
:neo4j_version: 3.5.6
:config_prefix: org.neo4j.driver
:driver_manual_base: https://neo4j.com/docs/driver-manual/1.7/
:gh_base: https://github.com/neo4j/neo4j-java-driver-spring-boot-starter

== Intro

=== What's in the box?

The Neo4j Java Driver Spring Boot starter provides both a Spring Boot `autoconfigure` and a `starter` module.
The `autoconfigure` module adds a single instance of `org.neo4j.driver.Driver` as a bean to the Spring Context if there is none
and registers health- and metric endpoints for all Driver-beans if the necessary Spring infrastructure is in place.

It does not bring any mapping facilities in addition the available functions of the driver nor Spring Data integration.
Have a look at https://github.com/neo4j/sdn-rx[Spring Data Neo4j⚡️RX] for reactive Spring Data Neo4j repositories.

IMPORTANT: The driver instance is a long living object that provides short living sessions as needed.
           The instance does not need to be closed manually, that is done automatically when the application shuts down.
           There is no need for external connection pooling.
           This is done already in the driver and can be configured via properties.
           Please have a look at the chapter {driver_manual_base}/sessions-transactions/[Sessions and transactions].

=== Do I need the Neo4j Java Driver Spring Boot starter?

We recommend this starter for all new Spring Boot applications that want to use our new generation of drivers ("4.0").
The next generation of drivers is compatible with both 4.0.x and 3.5.x community and enterprise databases.
The starter takes away all the boilerplate code of configuring an instance of the driver and does support
https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html[externalized configuration]
for all aspects of the driver.

* [*] _You want to work directly with a 4.0 driver?_
  The starter is for you.
* [*] _You want Spring Data Neo4j⚡️RX repositories?_
  The automatic configuration for SDN-RX is dependent on this starter, so it is already there and you would use exactly
  the same as described in this manual to configure your connection
* [*] _You have the previous generation of Spring Data Neo4j or Neo4j-OGM?_
  While you cannot use the 4.0.x line of this starter, as Spring Data Neo4j + OGM is based on the previous generation of the Java driver,
  you can use the 1.7.x line of this starter. This configures a bean of the previous generation of the Neo4j driver and
  also configures Neo4j-OGM to use that bean instead of an internal one.

=== Does it work with the 1.7 series of the driver?

The 1.7.x line of the starter is for the 1.7.x line of the driver, the 4.0.x line for the 4.0..x of the driver.

=== Does it work with the embedded database?

No.

=== What's with the long name?

`neo4j-java-driver-spring-boot-starter` is quite a long name for a module, we get that.
However, it follows the official Spring Boot convention described https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-auto-configuration.html#boot-features-custom-starter-naming[here].

> As a rule of thumb, you should name a combined module after the starter. For example, assume that you are creating a starter for "acme" and that you name the auto-configure module acme-spring-boot-autoconfigure and the starter acme-spring-boot-starter. If you only have one module that combines the two, name it acme-spring-boot-starter.

Our "acme" module is the Neo4j Java Driver, project name `neo4j-java-driver` and things add up from there, that's all.

== Getting started

As with any other Spring Boot starter, the only thing you have to do is to include the starter module via your dependency management.
If you don't configure anything, than the starter assumes `bolt://localhost:7687` as Neo4j URI and a server that has disabled authentication.

If only a single URI is provided, than the configuration tries to use that.
Otherwise, it passes all URIs to the Java driver which in turn uses the first one that is a reachable `bolt+routing` instance.

The automatic configuration will fail fast if the driver cannot connect to a single Neo4j database or to a routing server.

The Neo4j driver supports three different programming models:

* Blocking database access (much like standard JDBC)
* Asynchronous programming based on JDKs completable futures and related infrastructure
* Reactive programming based on http://www.reactive-streams.org[Reactive Streams]

Those are all included in the same binary.
The reactive programming model however requires a 4.0 Neo4j server on the database side and reactive Spring on the other hand.
To make the following intro as accessible as possible, we only display the blocking database access.
Have a look at the {gh_base}/tree/master/examples[examples directory] for a reactive web application example.

=== Preparing the database

For this example, we stay within the https://neo4j.com/developer/movie-database/[movie graph],
as it comes for free with every Neo4j instance.

If you don't have a running database but Docker installed, please run:

[source,bash,subs="verbatim,attributes"]
[[start-docker-neo4j]]
.Start a local Neo4j instance inside Docker.
----
docker run --publish=7474:7474 --publish=7687:7687 neo4j:{neo4j_version}
----

You know can access http://localhost:7474/browser/?cmd=play&arg=movies[http://localhost:7474].
At first visit, you have to change your password. We chose `secret`  in the examples.
Note the command ready to run in the prompt.
Execute it to fill your database with some test data.

=== Create a new Spring Boot project

The easiest way to setup a Spring Boot project is https://start.spring.io[start.spring.io]
 (which is integrated in the major IDEs as well, in case you don't want to use the website).

Select the "Spring Web Starter" to get all the dependencies needed for creating a Spring based web application.
The Spring Initializr will take care of creating a valid project structure for you,
with all the files and settings in place for the selected build tool.

WARNING: Don't choose Spring Data Neo4j here, as it will get you the previous generation of Spring Data Neo4j including OGM and additional abstraction over the driver.

==== Maven

You can issue a CURL request against the Spring Initializer to create a basic Maven project:

[source,bash,subs="verbatim,attributes"]
[[generate-maven-project]]
.Create a basic Maven project with the Spring Initializr
----
curl https://start.spring.io/starter.tgz \
  -d dependencies=web,actuator \
  -d bootVersion={spring-boot_version} \
  -d baseDir=Neo4jSpringBootExample \
  -d name=Neo4j%20SpringBoot%20Example | tar -xzvf -
----

This will create a new folder `Neo4jSpringBootExample`.
As this starter is not yet on the initializer, you'll have to add the following dependency manually to your  `pom.xml`:

[source,xml,subs="verbatim,attributes"]
[[dependencies-maven]]
.Inclusion of the neo4j-java-driver-spring-boot-starter in a Maven project
----
<dependency>
	<groupId>{groupId}</groupId>
	<artifactId>{artifactId}</artifactId>
	<version>{neo4j-java-driver-spring-boot-starter_version}</version>
</dependency>
----

You would also add the dependency manually in case of an existing project.

==== Gradle

The idea is the same, just generate a Gradle project:

[source,bash,subs="verbatim,attributes"]
[[generate-gradle-project]]
.Create a basic Gradle project with the Spring Initializr
----
curl https://start.spring.io/starter.tgz \
  -d dependencies=web,actuator \
  -d type=gradle-project \
  -d bootVersion={spring-boot_version} \
  -d baseDir=Neo4jSpringBootExampleGradle \
  -d name=Neo4j%20SpringBoot%20Example | tar -xzvf -
----

The dependency for Gradle looks like this and must be added to `build.gradle`:

[source,groovy,subs="verbatim,attributes"]
.Inclusion of the neo4j-java-driver-spring-boot-starter in a Gradle project
----
dependencies {
    compile '{groupId}:{artifactId}:{neo4j-java-driver-spring-boot-starter_version}'
}
----

You would also add the dependency manually in case of an existing project.

==== Configuration

Now open any of those projects in your favorite IDE.
Find `application.properties` and configure your Neo4j credentials:

[source,properties]
----
org.neo4j.driver.uri=bolt://localhost:7687
org.neo4j.driver.authentication.username=neo4j
org.neo4j.driver.authentication.password=secret
----

This is the bare minimum of what you need to connect to a Neo4j instance.

Refer to <<Configuration options,the list of configuration properties>> for all options this driver supports.

While the above configuration is presented in the easiest format (an `application.properties` file),
you are of course free to use any other declarative way to define properties in Spring Boot.
Please checkout the chapter https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-external-config[Externalized Configuration].

NOTE: It is not necessary to add any programmatically configuration of the driver when you use this starter.
      While it may work, we strongly discourage and don't support additional, pragmatical configuration of the Neo4j driver when using this starter.


==== Example CRUD Controller

Add the following `@RESTController` to your application:

[source,java,subs="verbatim,attributes"]
[[MovieController1]]
.MovieController.java
----
package com.example.demo;

import java.util.List;

import org.neo4j.driver.AccessMode;
import org.neo4j.driver.Driver;
import org.neo4j.driver.Session;
import org.neo4j.driver.SessionConfig;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class MoviesController {

	private final Driver driver; // <1>

	public MoviesController(Driver driver) { // <2>
		this.driver = driver;
	}

	@GetMapping(path = "/movies", produces = MediaType.APPLICATION_JSON_VALUE) // <3>
	public List<String> getMovieTitles() {

		try (Session session = driver.session()) { // <4>
			return session.run("MATCH (m:Movie) RETURN m ORDER BY m.name ASC")
				.list(r -> r.get("m").asNode().get("title").asString());
		}
	}
}
----
<1> An instance field to hold the driver
<2> The driver is injected via constructor injection
<3> A mapping to the url `/movies`
<4> Using the driver to get a short lived session and issue a query on it

If you generated your application via the commands given above, you can now run the class `Neo4jSpringBootExampleApplication`
and after a short while, you can access http://localhost:8080/movies.

== Logging

The Neo4j Spring Boot starter uses a small shim to integrate the driver with Springs JCL abstraction.
Thus, all logging configuration can be done via Spring Boot's `application.properties`.
Important names used for logging are:

[source,properties]
----
logging.level.org.neo4j.driver.GraphDatabase = debug
logging.level.org.neo4j.driver.Driver = debug
----

If you ever have the need to debug outgoing and incoming Bolt messages, use those two names:

[source,properties]
----
logging.level.org.neo4j.driver.OutboundMessageHandler = debug
logging.level.org.neo4j.driver.InboundMessageDispatcher = debug
----

NOTE: The prefix `org.neo4j.driver` is specific to the Drivers integration with Spring Boot.

== Production-ready features

The Neo4j Spring Boot starter hooks into Spring Boot's https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready.html[Production-ready features] (or the so called Spring Boot Actuator).
This happens automatically when you add the Spring Boot Actuator Starter like this:

[source,xml,subs="verbatim,attributes"]
[[actuator-maven]]
.Spring Boot Starter Actuator dependency with Maven
----
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
----

or with Gradle:

[source,groovy,subs="verbatim,attributes"]
.Spring Boot Starter Actuator dependency with Gradle
----
dependencies {
    compile 'org.springframework.boot:spring-boot-starter-actuator'
}
----

We support both the https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html#production-ready-health[health-] and https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html[metrics-actuator].

=== Health information

Both reactive and imperative health checks are available,
with the reactive health checks having precedence when Project Reactor is detected.

When calling the health endpoint `/actuator/health` and the driver can reach a Neo4j instance, an unauthenticated user will see

[source,json]
.Health information
----
{
  "status": "UP"
}
----

and an authenticated user will see

[source,json]
.Health information
----
{
  "status": "UP",
  "details": {
    "neo4j": {
      "status": "UP",
      "details": {
        "server": "Neo4j/4.0.0@localhost(127.0.0.1):7687",
        "database": "neo4j"
      }
    }
  }
}
----

In case no instance is reachable, the status will be `DOWN` and the details carry the error message.

To disable the Neo4j health indicator, use the standard Spring Boot property `management.health.neo4j.enabled` with a value of `false`.

=== Driver metrics

`neo4j-java-driver-spring-boot-starter` comes with support for https://micrometer.io[Micrometer metrics] out of the box.
It detects Micrometer on the classpath and binds the metrics of all instances of `org.neo4j.driver.Driver`, that have enabled their metrics, to a micrometer registry.

To enable metrics for the driver instance provided by this starter, set `org.neo4j.driver.config.metrics-enabled` to true.

The following metrics are exposes

* `neo4j.driver.connections.inUse` (Gauge)
* `neo4j.driver.connections.timedOutToAcquire` (Counter)
* `neo4j.driver.connections.closed` (Counter)
* `neo4j.driver.connections.failedToCreate` (Counter)
* `neo4j.driver.connections.created` (Counter)
* `neo4j.driver.connections.idle` (Gauge)
* `neo4j.driver.connections.acquired` (Counter)

All metrics will have the tags `name` (the bean of the driver they belong to)
and `poolId` (the id of the connection pool, that contributed to the corresponding counter or gauge).

include::{manualIncludeDir}docs/configuration-options.adoc[]

:leveloffset: +1
include::{manualIncludeDir}examples/README.adoc[]
:leveloffset: -1